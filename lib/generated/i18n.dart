import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

//This file is automatically generated. DO NOT EDIT, all your changes would be lost.
class S implements WidgetsLocalizations {
  const S();

  static const GeneratedLocalizationsDelegate delegate =
    GeneratedLocalizationsDelegate();

  static S of(BuildContext context) => Localizations.of<S>(context, S);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  String get color_of_flower => "colour of flowers";
  String get default_language => "default language";
  String get feedback => "Feedback";
  String get habitats => "habitats";
  String get pref_language => "Preferred language";
  String get settings => "Settings";
}

class $de extends S {
  const $de();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "Habitat";
  @override
  String get color_of_flower => "Blütenfarbe";
}

class $hi extends S {
  const $hi();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "पर्यावास";
  @override
  String get color_of_flower => "फूलों का रंग";
}

class $no extends S {
  const $no();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "voksested";
  @override
  String get color_of_flower => "farge på blomster";
}

class $fi extends S {
  const $fi();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "kasvupaikka";
  @override
  String get color_of_flower => "kukkien väri";
}

class $ru extends S {
  const $ru();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "ареалы";
  @override
  String get color_of_flower => "окраска цветков";
}

class $pt extends S {
  const $pt();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitat";
  @override
  String get color_of_flower => "cor das flores";
}

class $lt extends S {
  const $lt();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "buveinių";
  @override
  String get color_of_flower => "spalva gėlės";
}

class $hr extends S {
  const $hr();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "staništa";
  @override
  String get color_of_flower => "boja cvjetova";
}

class $lv extends S {
  const $lv();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "biotopi";
  @override
  String get color_of_flower => "krāsu ziedi";
}

class $fr extends S {
  const $fr();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitats";
  @override
  String get color_of_flower => "couleur des fleurs";
}

class $hu extends S {
  const $hu();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "élettér";
  @override
  String get color_of_flower => "a virágok színe";
}

class $uk extends S {
  const $uk();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "середовище";
  @override
  String get color_of_flower => "забарвлення квіток";
}

class $sk extends S {
  const $sk();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get feedback => "Pripomienky";
  @override
  String get settings => "Nastavenia";
  @override
  String get habitats => "lokalita";
  @override
  String get color_of_flower => "farba kvetov";
  @override
  String get pref_language => "Preferovaný jazyk";
  @override
  String get default_language => "prednastavený jazyk";
}

class $sl extends S {
  const $sl();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitate";
  @override
  String get color_of_flower => "barva cvetov";
}

class $id extends S {
  const $id();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitat";
  @override
  String get color_of_flower => "warna bunga";
}

class $sr extends S {
  const $sr();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "станишта";
  @override
  String get color_of_flower => "боја цвећа";
}

class $sv extends S {
  const $sv();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "växtplats";
  @override
  String get color_of_flower => "färg på blommor";
}

class $en extends S {
  const $en();
}

class $it extends S {
  const $it();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitat";
  @override
  String get color_of_flower => "colore dei fiori";
}

class $es extends S {
  const $es();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "localidad";
  @override
  String get color_of_flower => "color de la flor";
}

class $et extends S {
  const $et();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "elupaikade";
  @override
  String get color_of_flower => "värvi lilled";
}

class $cs extends S {
  const $cs();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "ekologie";
  @override
  String get color_of_flower => "barva květů";
}

class $ar extends S {
  const $ar();

  @override
  TextDirection get textDirection => TextDirection.rtl;

  @override
  String get habitats => "موطن";
  @override
  String get color_of_flower => "لون الزهور";
}

class $pa extends S {
  const $pa();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "ਆਵਾਸ";
  @override
  String get color_of_flower => "ਫੁੱਲ ਦਾ ਰੰਗ";
}

class $en_US extends S {
  const $en_US();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get color_of_flower => "color of flowers";
}

class $ja extends S {
  const $ja();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "生息地";
  @override
  String get color_of_flower => "花の色";
}

class $fa extends S {
  const $fa();

  @override
  TextDirection get textDirection => TextDirection.rtl;

  @override
  String get habitats => "زیستگاه ها";
  @override
  String get color_of_flower => "رنگ گل";
}

class $pl extends S {
  const $pl();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "Habitat";
  @override
  String get color_of_flower => "Kolor kwiatów";
}

class $da extends S {
  const $da();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "vækststeder";
  @override
  String get color_of_flower => "blomsterfarve";
}

class $he extends S {
  const $he();

  @override
  TextDirection get textDirection => TextDirection.rtl;

  @override
  String get habitats => "בתי גידול";
  @override
  String get color_of_flower => "צבע של פרחים";
}

class $ro extends S {
  const $ro();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "habitatul";
  @override
  String get color_of_flower => "culoarea florilor";
}

class $nl extends S {
  const $nl();

  @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get habitats => "standplaats";
  @override
  String get color_of_flower => "kleur van de bloemen";
}

class GeneratedLocalizationsDelegate extends LocalizationsDelegate<S> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale("de", ""),
      Locale("hi", ""),
      Locale("no", ""),
      Locale("fi", ""),
      Locale("ru", ""),
      Locale("pt", ""),
      Locale("lt", ""),
      Locale("hr", ""),
      Locale("lv", ""),
      Locale("fr", ""),
      Locale("hu", ""),
      Locale("uk", ""),
      Locale("sk", ""),
      Locale("sl", ""),
      Locale("id", ""),
      Locale("sr", ""),
      Locale("sv", ""),
      Locale("en", ""),
      Locale("it", ""),
      Locale("es", ""),
      Locale("et", ""),
      Locale("cs", ""),
      Locale("ar", ""),
      Locale("pa", ""),
      Locale("en", "US"),
      Locale("ja", ""),
      Locale("fa", ""),
      Locale("pl", ""),
      Locale("da", ""),
      Locale("he", ""),
      Locale("ro", ""),
      Locale("nl", ""),
    ];
  }

  LocaleListResolutionCallback listResolution({Locale fallback}) {
    return (List<Locale> locales, Iterable<Locale> supported) {
      if (locales == null || locales.isEmpty) {
        return fallback ?? supported.first;
      } else {
        return _resolve(locales.first, fallback, supported);
      }
    };
  }

  LocaleResolutionCallback resolution({Locale fallback}) {
    return (Locale locale, Iterable<Locale> supported) {
      return _resolve(locale, fallback, supported);
    };
  }

  Locale _resolve(Locale locale, Locale fallback, Iterable<Locale> supported) {
    if (locale == null || !isSupported(locale)) {
      return fallback ?? supported.first;
    }

    final Locale languageLocale = Locale(locale.languageCode, "");
    if (supported.contains(locale)) {
      return locale;
    } else if (supported.contains(languageLocale)) {
      return languageLocale;
    } else {
      final Locale fallbackLocale = fallback ?? supported.first;
      return fallbackLocale;
    }
  }

  @override
  Future<S> load(Locale locale) {
    final String lang = getLang(locale);
    if (lang != null) {
      switch (lang) {
        case "de":
          return SynchronousFuture<S>(const $de());
        case "hi":
          return SynchronousFuture<S>(const $hi());
        case "no":
          return SynchronousFuture<S>(const $no());
        case "fi":
          return SynchronousFuture<S>(const $fi());
        case "ru":
          return SynchronousFuture<S>(const $ru());
        case "pt":
          return SynchronousFuture<S>(const $pt());
        case "lt":
          return SynchronousFuture<S>(const $lt());
        case "hr":
          return SynchronousFuture<S>(const $hr());
        case "lv":
          return SynchronousFuture<S>(const $lv());
        case "fr":
          return SynchronousFuture<S>(const $fr());
        case "hu":
          return SynchronousFuture<S>(const $hu());
        case "uk":
          return SynchronousFuture<S>(const $uk());
        case "sk":
          return SynchronousFuture<S>(const $sk());
        case "sl":
          return SynchronousFuture<S>(const $sl());
        case "id":
          return SynchronousFuture<S>(const $id());
        case "sr":
          return SynchronousFuture<S>(const $sr());
        case "sv":
          return SynchronousFuture<S>(const $sv());
        case "en":
          return SynchronousFuture<S>(const $en());
        case "it":
          return SynchronousFuture<S>(const $it());
        case "es":
          return SynchronousFuture<S>(const $es());
        case "et":
          return SynchronousFuture<S>(const $et());
        case "cs":
          return SynchronousFuture<S>(const $cs());
        case "ar":
          return SynchronousFuture<S>(const $ar());
        case "pa":
          return SynchronousFuture<S>(const $pa());
        case "en_US":
          return SynchronousFuture<S>(const $en_US());
        case "ja":
          return SynchronousFuture<S>(const $ja());
        case "fa":
          return SynchronousFuture<S>(const $fa());
        case "pl":
          return SynchronousFuture<S>(const $pl());
        case "da":
          return SynchronousFuture<S>(const $da());
        case "he":
          return SynchronousFuture<S>(const $he());
        case "ro":
          return SynchronousFuture<S>(const $ro());
        case "nl":
          return SynchronousFuture<S>(const $nl());
        default:
          // NO-OP.
      }
    }
    return SynchronousFuture<S>(const S());
  }

  @override
  bool isSupported(Locale locale) =>
    locale != null && supportedLocales.contains(locale);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;
}

String getLang(Locale l) => l == null
  ? null
  : l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
